/*
 * Human Tasks:
 * 1. Verify proper navigation setup in the NavGraph for this screen
 * 2. Test offline message sending and syncing behavior
 * 3. Validate accessibility features with TalkBack
 * 4. Test message list performance with large datasets
 */

package com.founditure.presentation.message

// androidx.compose.material3:material3:1.1.0
import androidx.compose.material3.*
import androidx.compose.material3.MaterialTheme

// androidx.compose.foundation:foundation:1.5.0
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState

// androidx.compose.runtime:runtime:1.5.0
import androidx.compose.runtime.*

// androidx.compose.ui:ui:1.5.0
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.semantics.contentDescription
import androidx.compose.ui.semantics.semantics
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp

// androidx.hilt.navigation.compose:hilt-navigation-compose:1.0.0
import androidx.hilt.navigation.compose.hiltViewModel

// Internal imports
import com.founditure.presentation.components.FounditureTextField
import com.founditure.domain.model.Message
import com.founditure.presentation.theme.Typography

/**
 * Main chat screen composable that implements the real-time messaging interface.
 * 
 * Requirements addressed:
 * - Real-time messaging (1.2 System Overview/High-Level Description)
 * - Core Features/Messaging (1.3 Scope/In-Scope Elements)
 * - User Interface Design (3.1.1 Design Specifications)
 *
 * @param navController Navigation controller for screen navigation
 * @param userId ID of the user to chat with
 */
@Composable
fun ChatScreen(
    navController: NavController,
    userId: String
) {
    val viewModel: ChatViewModel = hiltViewModel()
    val uiState by viewModel.uiState.collectAsState()
    val messageInput = remember { mutableStateOf("") }
    val listState = rememberLazyListState()

    // Fetch messages when the screen is first displayed
    LaunchedEffect(userId) {
        viewModel.getMessages(userId)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = "Chat",
                        style = Typography.titleLarge
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController.navigateUp() }) {
                        Icon(
                            imageVector = Icons.Default.ArrowBack,
                            contentDescription = "Navigate back"
                        )
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // Message list
            Box(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxWidth()
            ) {
                when (uiState) {
                    is ChatUiState.Success -> {
                        MessageList(
                            messages = (uiState as ChatUiState.Success).messages,
                            currentUserId = userId,
                            onMessageDisplayed = { messageId ->
                                viewModel.markMessageAsRead(messageId)
                            }
                        )
                    }
                    is ChatUiState.Loading -> {
                        CircularProgressIndicator(
                            modifier = Modifier.align(Alignment.Center)
                        )
                    }
                    is ChatUiState.Error -> {
                        Text(
                            text = (uiState as ChatUiState.Error).message,
                            color = MaterialTheme.colorScheme.error,
                            style = Typography.bodyMedium,
                            modifier = Modifier
                                .align(Alignment.Center)
                                .padding(16.dp)
                        )
                    }
                    else -> Unit
                }
            }

            // Message input
            MessageInput(
                value = messageInput.value,
                onValueChange = { messageInput.value = it },
                onSendMessage = { message ->
                    viewModel.sendMessage(
                        Message(
                            id = "",  // Will be generated by backend
                            senderId = userId,
                            content = message,
                            timestamp = System.currentTimeMillis(),
                            isRead = false
                        )
                    )
                    messageInput.value = ""
                }
            )
        }
    }
}

/**
 * Composable that displays the list of messages with proper styling and layout.
 *
 * @param messages List of messages to display
 * @param currentUserId ID of the current user
 * @param onMessageDisplayed Callback when a message is displayed and should be marked as read
 */
@Composable
private fun MessageList(
    messages: List<Message>,
    currentUserId: String,
    onMessageDisplayed: (String) -> Unit
) {
    val listState = rememberLazyListState()

    LazyColumn(
        state = listState,
        reverseLayout = true,
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp),
        modifier = Modifier.fillMaxSize()
    ) {
        items(messages) { message ->
            MessageItem(
                message = message,
                isFromCurrentUser = message.isFromUser(currentUserId),
                modifier = Modifier.fillMaxWidth()
            )
            
            // Mark message as read when displayed
            if (!message.isRead && !message.isFromUser(currentUserId)) {
                LaunchedEffect(message.id) {
                    onMessageDisplayed(message.id)
                }
            }
        }
    }
}

/**
 * Composable that displays a single message item with proper styling.
 *
 * @param message Message to display
 * @param isFromCurrentUser Whether the message is from the current user
 * @param modifier Modifier for customizing the layout
 */
@Composable
private fun MessageItem(
    message: Message,
    isFromCurrentUser: Boolean,
    modifier: Modifier = Modifier
) {
    val alignment = if (isFromCurrentUser) Alignment.End else Alignment.Start
    val backgroundColor = if (isFromCurrentUser) {
        MaterialTheme.colorScheme.primaryContainer
    } else {
        MaterialTheme.colorScheme.surfaceVariant
    }
    val textColor = if (isFromCurrentUser) {
        MaterialTheme.colorScheme.onPrimaryContainer
    } else {
        MaterialTheme.colorScheme.onSurfaceVariant
    }

    Column(
        modifier = modifier,
        horizontalAlignment = alignment
    ) {
        Surface(
            shape = MaterialTheme.shapes.medium,
            color = backgroundColor,
            modifier = Modifier.semantics {
                contentDescription = "Message: ${message.content}"
            }
        ) {
            Column(
                modifier = Modifier.padding(12.dp)
            ) {
                Text(
                    text = message.content,
                    color = textColor,
                    style = Typography.bodyLarge
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = formatTimestamp(message.timestamp),
                    color = textColor.copy(alpha = 0.7f),
                    style = Typography.labelSmall,
                    textAlign = TextAlign.End,
                    modifier = Modifier.align(Alignment.End)
                )
            }
        }
    }
}

/**
 * Composable that renders the message input field with send button.
 *
 * @param value Current input value
 * @param onValueChange Callback when input value changes
 * @param onSendMessage Callback when send button is clicked
 */
@Composable
private fun MessageInput(
    value: String,
    onValueChange: (String) -> Unit,
    onSendMessage: (String) -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        FounditureTextField(
            value = value,
            onValueChange = onValueChange,
            label = "Message",
            modifier = Modifier.weight(1f),
            maxLines = 4
        )
        
        Spacer(modifier = Modifier.width(8.dp))
        
        IconButton(
            onClick = {
                if (value.isNotBlank()) {
                    onSendMessage(value)
                }
            },
            enabled = value.isNotBlank()
        ) {
            Icon(
                imageVector = Icons.Default.Send,
                contentDescription = "Send message",
                tint = MaterialTheme.colorScheme.primary
            )
        }
    }
}

/**
 * Formats a timestamp into a human-readable string.
 *
 * @param timestamp Timestamp in milliseconds
 * @return Formatted time string
 */
private fun formatTimestamp(timestamp: Long): String {
    val dateFormat = SimpleDateFormat("HH:mm", Locale.getDefault())
    return dateFormat.format(Date(timestamp))
}